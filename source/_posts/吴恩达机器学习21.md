---
title: 吴恩达机器学习——梯度下降法
date: 2020-02-04 11:22:33
cover: https://upload.wikimedia.org/wikipedia/commons/6/68/Gradient_ascent_%28surface%29.png
tags: 
- 机器学习
- 算法
categories:
- [笔记]
math: true
---


太惨了，因为七牛云的域名关系，这个内容里面的图片暂时无法访问了，现在有没有时间去弄这些东西，这能暂时搁置，后面有时间的话再把那些图片找回来，目前的图片已经转移到腾讯云上来了，后面应该是都可以访问的！！！

---
---

之前老师让我们去看机器学习的内容,找到了网上普遍推荐的吴恩达老师的机器学习视频,在Coursrea上看了一点点,后面因为网络问题(~~大家都知道,大天朝的高墙永远耸立~~)放弃扔那儿了,最近几天新冠病毒肆虐,在家闲的无聊又不想看考研的东西,也不想写论文(~~真不是我不想,但是我懒~~)就把它重新拿出来看了。并且看了各位大佬的blog之后深觉挫败，想要把自己也伪装成一个大佬，所以写了这篇文章。有什么问题可以留言哦！！`\(^o^)/`
<!--more-->

# 关于机器学习算法的分类
目前来说较为明确的分类是:

## 监督学习 
需要预先准备已经有正确结果的数据对模型进行优化调整

* 回归
* 分类

## 非监督学习
没有预先准备好的数据集,通过对数据内部结构的挖掘找出各数据间的关系来达到预定目标

* 聚类
* 分离异常值([鸡尾酒聚会效应](https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E4%BC%9A%E6%95%88%E5%BA%94))

# 第一个算法:单变量线性回归
回归也就是我们通常用到的拟合,在实际的科研当中,很多时候回需要对我们得到的数据进行处理,用一个函数/曲线来拟合数据间的关系。实现这个拟合过程的算法就叫做回归算法
**单变量线性回归**(Linear Regression with one Variable)指的是只有一个变量的回归过程,是线性回归里面最简单的,也是整个机器学习中最简单的算法之一(学过高中数学的应该都能理解她的含义,所以这里不过的赘述)

## 构建模型
我们假设y(我们想要的结果)和x(我们所有的数据)之间具有如下的关系:

$model:  y = \theta_0+\theta_1x=h_\theta(x)$ $\theta_i$指的是模型的参数
![机器学习模型示意图](http://q532jr91q.bkt.clouddn.com/blogpic_25212f5fb2b83b0478db932c17fe3de7)

## 构建代价函数
模型建立好后，需要对参数进行调整，调整参数的过程一般来说是用另外的一个算法/模型来确定什么参数是最适合的(就像是直接将所有有可能适合的参数带入模型,然后将预测结果和正确的结果作对比,结果高度吻合的参数就是最优参数),我们把这个算法(函数)叫做**代价函数**(cost function),也通常翻译为损失函数

最常用的代价函数算法是**平方差**(Squared error function)**方法**,也就是最小二乘法;它的原理是:预测的结果和实际的结果差值最小时的参数是最好的参数([可以在这里找到关于该方法的具体定义](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95#4)),我们这里采用的算法和最基础的算法不一样,只是在该原理上优化,采用数据集中所有数据的平均平方差最小作为最终的代价函数

$cost\ function :  J(\theta_0,\theta_1)=\dfrac{1}{2m}\sum\limits_{i=0}^m(h_\theta(x_i)-y_i)^2$ 
$J(\theta_0,\theta_1)$用以表示cost function
![cost function](http://q532jr91q.bkt.clouddn.com/blogpic_f5b0fd9fd99854069b00a3b660c304a5)
我把官方给的资料贴出来,可以点进去之后放大查看!

## 实现目标
我们现在的目的是调整$\theta_0,\theta_1$的值,使得我们的代价函数的值最小,这个时候的$\theta_0,\theta_1$就是最适合的模型参数
我们的思路是:

* start with some $\theta_0,\theta_1$
* keep changing $\theta_0,\theta_1$ to reduce $J(\theta_0,\theta_1)$ until we hopefully end up at a minimum

我们这里采用**梯度下降算法**(Gradient descent algorithm)来解决这个问题([点击我去往"梯度下降法"的百度页](https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95))
通俗的来讲就是:

> 假设你现在在一座山上的某一个位置,突然有急事需要你以最快 的速度赶到山下(最低的位置)。梯度下降算法要求你在当前位置找到坡最陡的方向,沿着这个方向走一段路程到达下一个点(不考虑你是否真的能够从那个地方走,就假如你会飞吧!)。在这个点又重复上面一样的做法,直到最低的位置(至于我们怎么知道某个位置就是最低的位置,在后面会讲到,梯度下降法不需要我们考虑这个问题)
> 
> ![梯度下降法的三维图像表示](https://upload.wikimedia.org/wikipedia/commons/6/68/Gradient_ascent_%28surface%29.png)

### 数学表示
我们将梯度下降法的数学表达写成下面的形式:

$repeat\ until\ convergence\{\ \theta_j:=\theta_j-\alpha\frac{\partial}{\partial \theta_j}J(\theta_0,\theta_1)\ $,
$for\  j=0\ and\ j=1\}$

其中$\alpha$指的是学习效率,相当于你下山的时候每一步所跨的距离                                            
值得我们注意的是,这里的 $:=$ 表示的是赋值操作,即把运算所得的值还给原来的变量，学过程序设计的同学应该都知道的。但是这里的$\theta_0,\theta_1$需要同时赋值(在本文所讲的单变量线性回归当中是这样的,也有其他的算法不是同时赋值的)

### 算法特性
我们可以看到在我们的算法使用了参数减去该参数的偏导数来进行梯度的下降,我们现在来解释为什么我们要使用这样的方法(或者说这个方法有什么样的特征)

#### 关于$\alpha$
对于单个参数的代价函数$J(\theta)$,有:
$\theta := \theta-\alpha\frac{\partial}{\partial\theta}J(\theta)$

如果$\alpha$太小的话,$\theta$收敛的速度将会很慢(对应你下山的速度很慢,等你到的时候人家都已经解决完所有的事情了,要你有何用?)
![a小](http://q532jr91q.bkt.clouddn.com/blogpic_cf39a956dd8e19a9c13e604da18086b2)
如果$\alpha$太大的话,$\theta$将会有可能直接跳过最适合的值(对应你跑太快没注意其实你已经过了你要去的地方)
![a大](http://q532jr91q.bkt.clouddn.com/blogpic_e9e557d0d03daf75c9a1842ca53a3278)

#### 关于初始点
如果初始点在最小点的左边,$\theta$的传递将会使得$\theta$向右边移动,从而趋向最小点($\alpha$将会乘以一个负数,即$\theta$将会减去一个负数)
![init左](http://q532jr91q.bkt.clouddn.com/blogpic_c24250417de5ef186514c6ec53f5149b)
同理有:初始点在最小点右边时,$\theta$将会向左边移动,从而趋向最小点
![init右](http://q532jr91q.bkt.clouddn.com/blogpic_230b8fc028714b56ce423eb36c6de4ac)
在梯度下降的过程中,$\theta$的值不断变化,$\frac{\partial}{\partial\theta}J(\theta)$的值也在不断变化,以下图举例来说,这个偏微分的值是在逐渐减小的(必定是这样的,因为你要取得的值是导数为0的最小值,**如果函数处处连续可导,则必然趋向最小点的过程中导数的绝对值是在减小的**)
![导数减小](http://q532jr91q.bkt.clouddn.com/blogpic_50ba003760c1fe93a86e4bca9376b0df)

#### 关于最优解
当我们的$\theta$到达最小值时,偏导数就变为零了,这个时候式子就变成了:
$\theta=\theta-\alpha(0)=\theta$
$\theta$就已经收敛到这个位置不再变化,即使在整个函数中还有更小的值,但是我们的算法已经不想动了。也就是梯度下降法实际上只能找到局部最优解,(你可以这么理解,你下山其实是为了喝水,而只要有一个窝窝(导数为零)在就有水的存在,所以你就不用去找整座山最低的地方)
![局部最优](http://q532jr91q.bkt.clouddn.com/blogpic_6c4df1ddaf629e5d741ccb91965678cb)
事实上,在我们的线性回归当中,代价函数一般来说是不会像上图中那样有很多个极值点(导数为零),基本都只有一个也就是最小点,所以我们的局部最优解其实就是全局最优解。所以在本文的问题中,该算法是比较合理的!

如果你想对梯度下降法有更进一步的了解,或者还不是很理解你可以[点击我O(∩_∩)O哈哈~](https://zhuanlan.zhihu.com/p/36902908)
要不然你就自己上网搜!!!!!!网上很多大佬厉害着呢!

# 后记
上面我们已经建立好了模型和算法,剩下的事就是将算法转变为代码
然而我在写这篇文章的时候花了很多时间,因为我在没有配置好的情况下使用了latex格式的数学公式,导致了非常多的bug。
![bug](http://q532jr91q.bkt.clouddn.com/blogpic_8b2a6b0700feb1a4cdd03591e93a4fd2)而作为菜鸡的我对此简直是焦麻了！`~~~~(>_<)~~~~`所以暂时把这边文章放着,等后面有时间了就把这个算法的Python代码弄好贴上来,嘿嘿!(吴恩达的视频里没有这个算法的代码实现的内容,所以需要自己动手)

另外,为了更好的学习,我把网易云课堂上吴恩达老师视频的链接放到这里(因为它比较系统,还有文档可以下载!)
[快点我去网易云课堂学习吧](https://study.163.com/course/introduction/1004570029.htm)